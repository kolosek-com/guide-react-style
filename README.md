## React Stateless Functional Components (React 0.14 or newer)
### [Tutorial](https://hackernoon.com/react-stateless-functional-components-nine-wins-you-might-have-overlooked-997b0d933dbc)  

* **No Class Needed**  
Plain functions are generally preferable, and eliminating the class related cruft like extends and the constructor in the example below are a nice win.
* **No** `this` **Keyword**  
`<a>onClick={this.sayHi.bind(this)}>Say Hi</a>`  
`<a>onClick={sayHi}>Say Hi</a>`  
* **Easy to Understand**
* **Easy to Test**

[<img src="https://cdn-images-1.medium.com/max/1000/1*zyaxLgvQHfgaDjMoP90XAw.png">](https://hackernoon.com/react-stateless-functional-components-nine-wins-you-might-have-overlooked-997b0d933dbc)

## PropTypes
### [Official Page](https://facebook.github.io/react/docs/typechecking-with-proptypes.html)  
### [Tutorial](https://developer.fortnox.se/blog/proptypes-in-react-js/)

In short, PropTypes are just for helping the developer understand the component easier, and help debug it when there is a  prop type mismatch.

* You can easily open up a component and check which props are required and what type they should be.
* When things get messed up React will give you an awesome error message in the console, saying which props is wrong/missing plus the render method that caused the problem.

**Example:** 
```
propTypes: {
  size: React.PropTypes.number,
  position: React.PropTypes.string.isRequired,
}
```
In this example we can see that the component should receive two props. One should be a number, but it's value is not required (can be null or undefined, but it cannot have a value of any type other than integer), while the other prop should be a string, and it's value is required.

[//]: # (-------------------------------------------------------------------------------)

## Presentational and Container Components (state awareness)
> "Container components are components that are aware of Redux" - the internet  
> "Fat and Skinny, Smart and Dumb, Stateful and Pure, Screens and Components, etc" - [Dan Abramov](https://twitter.com/dan_abramov)    

### [Official Redux page](http://redux.js.org/docs/basics/UsageWithReact.html#presentational-and-container-components)    
### [Tutorial](https://medium.com/@dan_abramov/smart-and-dumb-components-7ca2f9a7c7d0) by [Dan Abramov](https://twitter.com/dan_abramov)  
### [Tutorial](http://www.thegreatcodeadventure.com/the-react-plus-redux-container-pattern/)  

React bindings for Redux embrace the idea of separating presentational and container components. You’ll find your components much easier to reuse and reason about if you divide them into (these) two categories. This approach also makes it easier to write stateless presentational components, and it also simplifies testing of a component.

|              | Presentational                  | Container                                     |
|:------------:| :-----------------------------: |:--------------------------------------------: |
|Purpose       | How things look (markup, styles)| How things work (data fetching, state updates)|
|Aware of Redux| No                              | Yes                                           |
|To read data  | Read data from props            | Subscribe to Redux state                      |
|To change data| Invoke callbacks from props     | Dispatch Redux actions                        |
|Are written   | By hand                         | Usually generated by React Redux              |

**Example of a container:**  
```
// homeContainer.js
import { connect } from 'react-redux'
import { someAction } from './actions'
import Home from './home'

const mapStateToProps = state => ({
  data: state.main.data,
})

const mapDispatchToProps = {
  someAction,
}

export default connect(
  mapStateToProps,
  mapDispatchToProps
)(Home) // Home is wrapped in it's container and exported as such

```
We can see in this code snippet that the `Main` component is wrapped in it's own container. This container will be imported instead of the `Home` component (in Routes, other components, etc...) with: `import Home from 'homeContainer'`.
Components that are wrapped in a container will receive everything from the container through props. If view components are saved as `.jsx` files, containers are `.js` as they do not render anything. 

[//]: # (-------------------------------------------------------------------------------)

## Linting
> "Linting is the process of running a program that will analyse code for potential errors"

### [ESlint official page](http://eslint.org/)  
### [Tutorial](https://raygun.com/blog/using-linters-for-faster-safer-coding-with-less-javascript-errors/)  

#### What is a linter?  
Linters have been around for a long time and probably exist in one shape or form for all languages. A linter is basically a parser that parses your code and looks for mistakes. It’s a great way to save time, maintain quality and write safer code. You can plug linters in to your code editor or copy-past your code to a linting tool. Lint-ing your code is a great thing to do no matter what language you code with. You can even lint HTML, CSS and JSON. There are many different types, but here I will focus on the four most popular Javascript linters.

React developers mostly use ESLint for javascript and JSX. There are predefined style guides available for ESlint like [Airbnb JSX style guide](https://github.com/airbnb/javascript/tree/master/react) that can be included (extended) in ESlint settings.

Example of a sublime linter plugin showing errors in console:  
[<img src="https://camo.githubusercontent.com/974b8eacb5b696a5debc1f41128f5b064b24d8d6/68747470733a2f2f6c68352e676f6f676c6575736572636f6e74656e742e636f6d2f2d38534c6e6d695433557a772f564431577a7431637a51492f41414141414141414262672f61363343536970307874302f773831332d683339362d6e6f2f6373686172706c696e7465722e706e67">](https://hackernoon.com/react-stateless-functional-components-nine-wins-you-might-have-overlooked-997b0d933dbc)

[//]: # (-------------------------------------------------------------------------------)

## Common Folder (helpers, components, decorators, ...)

Common folder holds the code that is being used in more than one place throughout the code.
Common folder structure differs per project/developer/company, but the idea is the same.
Example of common folder structure:  

**`Common`**
* `Helpers` (Contains functions, this folder is also named `utils`)  
`-> moneyHelper.js`  
`-> dateHelper.js`  
`-> someLogicHelper.js`
* `Components` (Contains components that are reused accros the app, (e.g., headers, buttons, etc...)  
`-> nextButton.jsx`  
`-> navHeader.jsx`  
`-> basicInfo.jsx`

This organizing pattern helps test functions, reduce redundant code and bugs

[//]: # (-------------------------------------------------------------------------------)

## Selectors (Improving React and Redux performance with Reselect)

> We define selectors as the functions that **retrieve snippets of the Redux state** for our React components

### [Reselect GitHub](https://github.com/reactjs/reselect)
### [Reselect tutorial](http://blog.rangle.io/react-and-redux-performance-with-reselect/)

* Selectors can compute derived data, allowing Redux to store the minimal possible state.
* Selectors are efficient. A selector is not recomputed unless one of its arguments change.
* Selectors are composable. They can be used as input to other selectors.

One of the more expensive operations that React can perform is the rendering cycle. When a component detects a change in input, the render cycle is triggered. Sometimes a component will have to perform calculations based on the it's input, in order to render the resulting values. Usually this shouldn't be an issue, but these calculations can become very costly, and impact performance. This is where selectors come to help. These costly operations can be written as a selector that will supply the subscribed components with the needed values, thus eliminating the logic from the component.

We define selectors as the functions that retrieve snippets of the Redux state for our React components. Using memoization, we can prevent unnecessary rerenders and recalculations of derived data which in turn will speed up our application. With memoized selectors, if the state tree is large, we don’t have to worry about expensive calculations being performed every time the state changes. We can also add additional flexibility to our frontend by breaking these out into individual components.

This is a powerful concept as it allows us to completely optimize which components should be rerendered, and when their derived state should be recalculated.  

Making these optimizations early in your application means less work in the future when you need to correct performance problems. One of the major benefits of moving our selectors out of our components means that we can easily test these derived data calculations just as we would any other JavaScript function. We simply mock our Redux state and then check for the expected output based on the state provided.

[<img src="http://blog.rangle.io/content/images/2016/06/image03-1.png">](http://blog.rangle.io/react-and-redux-performance-with-reselect/)

```
import { createSelector } from 'reselect'

const shopItemsSelector = state => state.shop.items
const taxPercentSelector = state => state.shop.taxPercent

const subtotalSelector = createSelector(
  shopItemsSelector,
  items => items.reduce((acc, item) => acc + item.value, 0)
)

const taxSelector = createSelector(
  subtotalSelector,
  taxPercentSelector,
  (subtotal, taxPercent) => subtotal * (taxPercent / 100)
)

export const totalSelector = createSelector(
  subtotalSelector,
  taxSelector,
  (subtotal, tax) => ({ total: subtotal + tax })
)

let exampleState = {
  shop: {
    taxPercent: 8,
    items: [
      { name: 'apple', value: 1.20 },
      { name: 'orange', value: 0.95 },
    ]
  }
}

console.log(subtotalSelector(exampleState)) // 2.15
console.log(taxSelector(exampleState))      // 0.172
console.log(totalSelector(exampleState))    // { total: 2.322 }
```

If you are using React Redux, you can call selectors as regular functions inside mapStateToProps()

[//]: # (-------------------------------------------------------------------------------)

## Normalizr

> Many APIs, return JSON data that has deeply nested objects. Using data in this kind of structure is often very difficult for JavaScript applications, especially those using Flux or Redux.  
> Essentially, normalizr takes a deeply nested javascript object and flattens it out

### [Normalizr GitHub](https://github.com/paularmstrong/normalizr)  
### [Normalizr with redux - tutorial](https://medium.com/farmdrop/using-normalizr-js-in-a-redux-store-96ab33991369)

The idea behind normalizr is to take an API response that has nested resources and flatten them. It's a simple idea with a great upside - it becomes much easier to query and manipulate data for your components. And this is even better combined with reselect

Consider a typical blog post. The API response for a single post might look something like this:
```
{
  "id": "123",
  "author": {
    "id": "1",
    "name": "Paul"
  },
  "title": "My awesome blog post",
  "comments": [
    {
      "id": "324",
      "commenter": {
        "id": "2",
        "name": "Nicole"
      }
    }
  ]
}
```
We have two nested entity types within our `article`: `users` and `comments`. Using various `schema`, we can normalize all three entity types down:
```
import { normalize, schema } from 'normalizr';

// Define a users schema
const user = new schema.Entity('users');

// Define your comments schema
const comment = new schema.Entity('comments', {
  commenter: user
});

// Define your article 
const article = new schema.Entity('articles', { 
  author: user,
  comments: [ comment ]
});

const normalizedData = normalize(originalData, article);

```
Now, `normalizedData` will be:
```
{
  result: "123",
  entities: {
    "articles": { 
      "123": { 
        id: "123",
        author: "1",
        title: "My awesome blog post",
        comments: [ "324" ]
      }
    },
    "users": {
      "1": { "id": "1", "name": "Paul" },
      "2": { "id": "2", "name": "Nicole" }
    },
    "comments": {
      "324": { id: "324", "commenter": "2" }
    }
  }
}
```

[//]: # (-------------------------------------------------------------------------------)

## Immutable

> *Shared mutable state is the root of all evil* - Pete Hunt, React.js Conf 2015

### [Immutable.js GitHub](https://github.com/facebook/immutable-js/)
### [Using Immutable Data Structures - Facebook](https://facebook.github.io/react/docs/optimizing-performance.html#using-immutable-data-structures)

* **Immutable**: once created, a collection cannot be altered at another point in time.
* **Persistent**: new collections can be created from a previous collection and a mutation such as set. The original collection is still valid after the new collection is created.
* **Structural Sharing**: new collections are created using as much of the same structure as the original collection as possible, reducing copying to a minimum to improve performance.

Immutability makes tracking changes cheap. A change will always result in a new object so we only need to check if the reference to the object has changed

[//]: # (-------------------------------------------------------------------------------)

## Testing

> First and foremost, start every feature with an end-to-end test. An end-to-end test is basically a test from the user’s perspective (click here, wait, confirm this text is displayed, etc.) The go-to library for end-to-end tests is [Selenium](http://www.seleniumhq.org/).

### [Jest official page](https://facebook.github.io/jest/)

[//]: # (-------------------------------------------------------------------------------)

## GraphQL

### [Zero to GraphQL in 30 Minutes](https://www.youtube.com/watch?v=UBGzsb2UkeY)  
### [Apollo client GitHub page](https://github.com/apollographql/apollo-client)
### [React Apollo GitHub page](https://github.com/apollographql/react-apollo)

[//]: # (-------------------------------------------------------------------------------)

## Redux form (v6 or newer)

### [Redux-form official page](http://redux-form.com/)
### [Redux-form GitHub](https://github.com/erikras/redux-form)

[//]: # (-------------------------------------------------------------------------------)

## Functional programming in JS

### [Learning Functional Programming with JavaScript](https://www.youtube.com/watch?v=e-5obm1G_FY)
### [Lodash FP](https://github.com/lodash/lodash/wiki/FP-Guide)

___
### Miscellaneous:
[Idiomatic redux tutorial](https://egghead.io/courses/building-react-applications-with-idiomatic-redux) - Great tutorial on [Egghead](https://egghead.io/) by [Dan Abramov](https://twitter.com/dan_abramov) that covers many aspects of this text  

Version **0.1**  
[Kolosek](https://kolosek.com/)  
